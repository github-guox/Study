# 招银网络（软开C++）

2018.10 https://blog.csdn.net/u012159812/article/details/82926242

**主要分为数据库，C/C++，操作系统，计算机网络等几个方面** <br/>

### 目录

[数据库](#数据库)
[C/C++](#C/C++)
[操作系统](#操作系统)
[计算机网络](#计算机网络)
[数据结构与算法](#数据结构与算法)
[其他](#其他)



### 数据库

1. **解释一下事务和 ACID 特性** <br/>

2. **事务隔离性** <br/>

3. **索引作用及好处坏处分析** <br/>

4. **EXISTS 和 IN 的区别** <br/>

5. **内连接，外连接和交叉连接** <br/>

6. **SQL中的触发器有什么作用** <br/>

7. **视图和表的区别** <br/>

8. **B+树的节点分裂** <br/>

9. 数据库知识（三大范式、结构、模型、基本语句） <br/>

10. 考察update语句长什么样子的难度

11. insert 和update 语句怎么写

    

### C/C++

1. **变量的4种不同存储类型**<br/>

   栈区：局部变量，形参临时变量<br/>堆区：由程序员自己申请 new malloc<br/>全局区：静态变量和全局变量<br/>常量区：常量字符串 等<br/>

2. **怎么定义一个常量指针(就近原则)**<br/>

   const int *a; 常量指针 ，指向值不可变<br/>int * const a;指针常量 ，指向位置不可变<br/>

3. **重载和重写，重定义的区别** <br/>

   一、重载（overload）<br/>

   指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。<br/>（1）相同的范围（在同一个作用域中）；<br/>（2）函数名字相同；<br/>（3）参数不同；<br/>（4）virtual 关键字可有可无。<br/>（5）返回值可以不同；<br/>

   二、重写（也称为覆盖 override）<br/>

   是指派生类重新定义基类的**虚函数**，特征是：<br/>（1）不在同一个作用域（分别位于派生类与基类） ；<br/>（2）函数名字相同；<br/>（3）参数相同；<br/>（4）基类函数必须有 virtual 关键字，不能有 static 。<br/>（5）返回值相同（或是协变），否则报错；<—-协变概念<br/>（6）**重写函数的访问修饰符可以不同**。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的。<br/>

   三、重定义（也成隐藏）<br/>

   （1）不在同一个作用域（分别位于派生类与基类） ；<br/>（2）函数名字相同；<br/>（3）返回值可以不同；<br/>（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 。<br/>（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。<br/>

   Child c； 此时执行c里的函数，父类函数被隐藏，自动执行子类里的函数。<br/>Father *b = &c； 此时执行b里的函数，覆盖了的会执行c中的，而重定义的仍执行b中的；<br/>

4. **结构体里面有没有构造函数和析构函数** <br/>

   可以有，和CALSS区别如下：<br/>class这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。<br/>class中默认继承方式是private，而struct的默认继承方式是public。<br/>class中默认成员访问权限是private，而struct的默认访问权限是public。<br/>

5. **拷贝构造函数为什么要用引用** <br/>

   不然在调用拷贝构造函数时，创建形参临时变量又会调用拷贝构造函数，会引起无限递归调用。<br/>

6. **C语言中单向链表和双向链表有什么区别** <br/>

   单向链表，只能访问当前节点的下一个节点。而双向链表可以访问下一个节点和前一个节点。<br/>

   单向循环链表，最后一个节点next指针为NULL，双向循环链表，最后一个节点next指针为*phead,*phead的pre指针为最后一个节点。<br/>

7. **跳跃表有没有听过** <br/>

   跳跃表基于有序单链表，在链表的基础上，每个结点不只包含一个指针，还可能包含多个指向后继结点的指针，这样就可以跳过一些不必要的结点，从而加快查找、删除等操作。 查询，删除，插入都是logn。<br/>

8. **java有内存回收的机制，C没有，什么时候出现野指针，什么时候出现内存泄漏** <br/>

   野指针：<br/>

   1. 定义的指针没有及时初始化。<br/>
   2. delete指针之后，没有及时置为NULL 。<br/>
   3. 指针超过了变量的作用范围。<br/>

   [C++中内存泄漏的几种情况](https://www.cnblogs.com/liushui-sky/p/7727865.html) <br/>

   

9. **new和malloc的区别** <br/>

   malloc是标准库函数，支持覆盖。new是运算符，支持重载。<br/>malloc和free仅仅分配和回收空间，而new和delete除了分配回收空间，还会调用构造函数和析构函数。<br/>malloc返回的是void类型指针，必须进行类型转换。new返回的是具体类型指针。<br/>

10. **静态成员函数为什么不能声明为虚函数** <br/>

    static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。<br/>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。<br/>ps:，静态成员函数也不能被声明为const和volatile. 而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。  volatile的道理也是如此。<br/>

11. **volatile用法**<br/>

    一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，**优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份**。<br/>

    下面是volatile变量的几个例子：<br/>1) 并行设备的硬件寄存器（如：状态寄存器） <br/>2) 多线程应用中被几个任务共享的变量  <br/>

    ****

    1. 一个参数既可以是const还可以是volatile吗？解释为什么。<br/>

       是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br/>

    2. 一个指针可以是volatile 吗？解释为什么。 <br/>

       是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。 <br/>

    3. 下面的函数有什么错误： <br/>

       ```c
       int square(volatile int *ptr) 
       { 
       		return *ptr * *ptr; 
       } 
       ```

       这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码： <br/>

       ```c
       int square(volatile int *ptr) 
       { 
           int a,b; 
           a = *ptr; 
           b = *ptr; 
           return a * b; 
       } 
       ```

       由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！ <br/>

       正确的代码如下： <br/>

       ```c
       long square(volatile int *ptr) 
       { 
           int a; 
           a = *ptr; 
           return a * a; 
       } 
       ```

       嵌入式编程中经常用到 volatile这个关键字，在网上查了下他的用法可以归结为以下两点：<br/>

       **一：告诉compiler不能做任何优化** <br/>

       ```wiki
          比如要往某一地址送两指令： 
          int *ip =...; #设备地址 
          *ip = 1; #第一个指令 
          *ip = 2; #第二个指令 
          以上程序compiler可能做优化而成： 
          int *ip = ...; 
          *ip = 2; 
          结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意： 
          volatile int *ip = ...; 
          *ip = 1; 
          *ip = 2; 
          即使你要compiler做优化，它也不会把两次付值语句间化为一。它只能做其它的优化。这对device driver程序员很有用。
       ```

       **二：表示用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。** <br/>

12. **构造函数和虚构函数中能否调用虚函数?**  <br/>

    - 构造函数跟虚构函数里面都可以调用虚函数，编译器不会报错。<br/>
    - C++ primer中说到最好别用。因为实现的是实调用而非虚调用，即同非虚函数相同。<br/>
    - 由于类的构造次序是由基类到派生类，所以在构造函数中调用虚函数，虚函数是不会呈现出多态的。派生类对象构造期间进入基类的构造函数时，**对象类型变成了基类类型，而不是派生类类型**。 所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。<br/>
      - 在概念上，构造函数的工作是为对象进行初始化。在构造函数完成之前，被构造的对象被认为“未完全生成”。当创建某个派生类的对象时，如果在它的基类的构造函数中调用虚函数，那么此时派生类的构造函数并未执行，所调用的函数可能操作还没有被初始化的成员，将导致灾难的发生。<br/>
    - 类的析构是从派生类到基类，当调用继承层次中某一层次的类的析构函数时意味着其派生类部分已经析构掉，所以也不会呈现多态。<br/>
    - 因此如果在基类中声明的纯虚函数并且在基类的析构函数中调用之，编译器会发生错误。<br/>

13. **构造函数能不能是虚函数** <br/>

    当然不能<br/>

    - https://www.cnblogs.com/youxin/p/4355946.html

    1. 构造一个对象的时候，**必须知道对象的实际类型**，而虚函数行为是在**运行期间**确定实际类型的。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。
    2. 虚函数的执行依赖于虚函数表。而**虚函数表在构造函数中进行初始化工作**，即初始化vptr，让他指向正确的虚函数表。**而在构造对象期间，虚函数表还没有被初始化**，将无法进行。

    ```wiki
    1. 从存储空间角度，虚函数对应一个指向vtable虚函数表的指针。但是这个指向vtable的指针其实是存储在对象的内存空间的。因此，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
    2. 从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
    3. 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。
    4. 从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有必要成为虚函数。
    5. 当一个构造函数被调用时，它做的首要的事情之一是初始化它的VPTR。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置VPTR指向它自己的VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的VTABLE的调用，而不是最后的VTABLE（所有构造函数被调用后才会有最后的VTABLE）。
    ```

14. 笔试题<br/>

    ```c++
    char str1[] = "abc"; 
    char str2[] = "abc"; 
    const char str3[] = "abc"; 
    const char str4[] = "abc"; 
    const char* str5 = "abc"; 
    const char* str6 = "abc"; 
    cout << boolalpha << ( str1==str2 ) << endl; // 输出什么？ 
    cout << boolalpha << ( str3==str4 ) << endl; // 输出什么？ 
    cout << boolalpha << ( str5==str6 ) << endl; // 输出什么？
    ```

    分别输出false,false,true。<br/>

    1. str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；
    2. tr3和 str4同上，只是按const语义，它们所指向的数据区不能修改。
    3. str5和str6并非数组而是字符指针，**并不分配存储区**，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。



### 操作系统

1. **进程和线程** <br/>

   进程：资源分配的基本单位，进程可以并发执行。<br/>线程：独立调度的基本单位，一个进程中可以有多个线程，他们共享进程资源<br/>

   区别：<br/>

   1. **拥有资源** 进程是资源分配基本单位。线程不拥有资源，可以访问隶属进程的资源<br/>
   2. **调度** 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程会引起进程切换<br/>
   3. **系统开销** 创建和撤销进程的开销远大于线程。进程切换会涉及CPU环境报错和新调度进程CPU环境设置，而线程切换只需**保存和设置少量寄存器内容**，开销很小<br/>
   4. **通信方面** 进程间通信需要**进程同步和互斥手段**以保证数据一致性，而线程间直接通过读写同一进程中的**数据段**来进行通信<br/>

2. **进程通信方式** <br/>

   1. 管道 只针对父子进程，半双工
   2. FIFO 去掉了父子进程限制 常用于客户-服务器应用程序中
   3. 消息队列 比FIFO更好
   4. 信号量
   5. 共享存储（共享内存） 最快的一种进程通信
   6. 套接字 解决不同机器间进程通信

3. **什么是死锁，必要条件，解决方法** <br/>

   死锁，是指多个进程在运行过程中因为争夺资源而造成的的一种僵局，造成他们都无法向前推进<br/>

   **必要条件**：<br/>

   1. 互斥条件 一段时间内某资源被一个进程占用，此时其他请求者只能等待<br/>
   2. 请求和保持条件 进程已经保持了至少一个资源，但又提出新的资源请求，而请求的资源被其他进程占有，此时请求进程阻塞，又不会释放自己已经占用的资源<br/>
   3. 不可剥夺条件 进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用时由自己释放<br/>
   4. 环路等待条件 请求资源形成资源环形链，即P0等待P1,p1等待p2,。。。pn等待p0；<br/>

   **解决办法** <br/>

   1. 预防死锁 破坏必要条件预防发生死锁
   2. 避免死锁
   3. 检测死锁
   4. 解除死锁

4. **sleep和wait的区别** <br/>

   1. sleep() 方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。 因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。
   2. wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程
   3. sleep() 和 wait() 的区别就是 调用sleep方法的线程不会释放对象锁，而调用wait() 方法会释放对象锁

   

### 计算机网络

1. **路由层协议除了ip协议还有哪些协议**<br/>

   ICMP<br/>

   IGMP<br/>

2. **arp协议有什么作用，具体的协议处理过程？** <br/>

   由IP地址得到MAC物理地址。<br/>

3. **TCP/IP四层，几个协议分别属于哪层** <br/>

   HTTP DNS 等应用层

   TCP UDP 运输层

   IP ICMP IGMP ARP RARP 网际层

   网络接口层

4. **TCP重传机制** <br/>

5. **DNS原理** <br/>

6. ISO的七层传递的数据是什么样子的

### 数据结构与算法

1. **各算法复杂度** <br/>

   最坏情况下复杂度最小的排序算法 堆排序<br/>数组基本有序 插入排序<br/>插排 时间复杂度与比较次数，移动次数都与初始序列有关<br/>快排 时间复杂度与比较次数，与移动次数都与初始序列有关<br/>归排 时间复杂度与初始序列无关，比较次数有关（有序序列），移动次数无关（无论怎么有序，还是每个元素拷贝到新的数组）<br/>选排 时间复杂度与初始序列无关，比较次数无关，移动次数无关<br/>冒排 时间复杂度与初始序列无关，比较次数无关，移动次数有关<br/>

2. **如何实现环形队列/链表** <br/>

   1. 环形队列:两个指针指向入口，插入一个数后，尾指针进行移动，头指针不动，删除一个数时，头指针向前移即可。注意插入数时，m_tail = m_tail % queue_capacity
   2. 环形链表:使用尾插法建立单链表，插入完最后一个数之后，该节点的next指针不指向NULL，而指向*phead。

3. **二叉树的遍历有哪几种** <br/>

   前序 根左右<br/>中序 左根右<br/>后序 左右根 递归和非递归都可实现，代码熟悉<br/>层序 使用一个栈来实现，从根节点开始遍历，左右节点入栈，然后访问左子节点，打印，同时左子节点的左右节点再次入栈，一直到栈为空，由此可以实现层序遍历。<br/>

   深度优先遍历<br/>



### 其他

1. 瀑布模型几个阶段

2. 动态链接库和静态链接库

3. 说10个编程的好习惯

4. 简要描述一个客户端服务器通信的步骤 Socket
5. 设计模式
6. 白盒测试
7. 某银行完成交易会有三方参与（银行、客户、第三方），交易完成三方的金额就发生改变，第三方获得佣金；现在完成了一个系统，保证了事务安全，对相应速度等之类有要求（记不太清了），刚开始交易量不大的时候没有什么问题，后来交易量渐渐大了，刚开始还可以用硬件升级来应对，可是后面硬件升级已经满足不了了，系统的性能开始下降？问：系统性能下降的所有可能原因，同时怎么解决？
8. 代码的质量很重要，你认为代码质量怎么体现？你会在自己开发的时候怎么保证自己的代码质量？
9. 



